<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ íŠœë¸Œ ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ì°¾ê¸°</title>
    <!-- 404 ë°©ì§€ìš© ê°„ë‹¨ íŒŒë¹„ì½˜ -->
    <link rel="icon" href="data:;base64,=">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f8f9fa;
            color: #212529;
        }
        .header {
            background-color: #ffffff;
            border-bottom: 1px solid #dee2e6;
            padding: 20px 0;
            margin-bottom: 20px;
        }
        .main-content {
            padding: 20px;
        }
        .video-card {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
            transition: transform 0.2s;
        }
        .video-card:hover {
            transform: translateY(-5px);
        }
        .video-card img {
            width: 100%;
            height: auto;
        }
        .card-body {
            padding: 15px;
        }
        .card-title {
            font-size: 1.1rem;
            font-weight: 700;
            height: 4.5em;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }
        .stats-badge {
            font-size: 0.7rem;
            font-weight: 700;
            padding: 3px 6px;
            margin-right: 3px;
            border-radius: 5px;
            display: inline-block;
        }
        .badge-subscribers { background-color: #ff4500; color: white; }
        .badge-views { background-color: #008080; color: white; }
        .badge-likes { background-color: #ffd700; color: #212529; }
        .badge-comments { background-color: #6a5acd; color: white; }
        .badge-velocity { background-color: #20c997; color: white; }
        .badge-likeRate { background-color: #ff6f61; color: white; }
        .badge-commentRate { background-color: #4dabf7; color: white; }
        .category-button {
            border-radius: 20px;
            margin: 5px;
            font-weight: 700;
        }
        .category-button.active {
            color: #fff !important;
            background-color: #dc3545 !important;
        }
        .badge-time {
            font-size: 0.8rem;
            background-color: #e9ecef;
            color: #495057;
        }
        .filter-bar { margin-top: 10px; }
        .filter-bar .btn-group + .btn-group { margin-left: 8px; }
        .trend-box {
            background-color: #ffffff;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.06);
            max-height: 80vh;
            overflow-y: auto;
            font-size: 0.95rem;
            margin-top: 10px;
        }
        .trend-box h5 { font-weight: 700; }
        .trend-meta { font-size: 0.8rem; }
        .trend-list { padding-left: 18px; margin-bottom: 0; }
        .trend-list li {
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .trend-keyword {
            flex: 1;
            margin-right: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }
        .trend-keyword:hover { text-decoration: underline; }
        .trend-score-badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 10px;
            background-color: #f1f3f5;
            color: #495057;
        }
        /* ì¦ê²¨ì°¾ê¸° ì˜ì—­ */
        .favorite-section {
            background-color: #fff;
            border-radius: 8px;
            padding: 8px 10px;
            margin-top: 10px;
            border: 1px solid #e9ecef;
        }
        .favorite-section-title {
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 4px;
        }
        .social-link-row small { font-size: 0.75rem; }
    </style>
</head>
<body>
<div class="container-fluid header">
    <div class="row align-items-center">
        <div class="col-md-3 text-center">
            <h3>ìœ íŠœë¸Œ íŠ¸ë Œë“œ ì°¾ê¸° ì œì‘ : ìëˆ</h3>
            <p class="text-muted">ê¸°ê°„ë³„ ì¸ê¸° ì˜ìƒ ë¶„ì„ Â· ì†Œì…œ íƒœê·¸ íƒìƒ‰</p>
        </div>

        <div class="col-md-6">
            <!-- ê²€ìƒ‰ì°½ -->
            <div class="input-group">
                <input id="searchInput" type="text" class="form-control" placeholder="ì œëª©/ì±„ë„/í‚¤ì›Œë“œ ê²€ìƒ‰ (ì˜ˆ: ì—¬ìº , íƒœì—°)">
                <button id="searchBtn" class="btn btn-primary">ê²€ìƒ‰</button>
            </div>

            <!-- ì–¸ì–´ / ì§€ì—­ ì„ íƒ -->
            <div class="mt-2">
                <span class="text-muted me-3">ì–¸ì–´ / ì§€ì—­ ì„ íƒ:</span>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" id="langKR" checked>
                    <label class="form-check-label" for="langKR">ğŸ‡°ğŸ‡· í•œêµ­</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" id="langEN">
                    <label class="form-check-label" for="langEN">ğŸ‡ºğŸ‡¸ ë¯¸êµ­(ì˜ì–´ê¶Œ)</label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="checkbox" id="langJP">
                    <label class="form-check-label" for="langJP">ğŸ‡¯ğŸ‡µ ì¼ë³¸</label>
                </div>
            </div>

            <!-- ğŸ”— ìœ íŠœë¸Œ / ì¸ìŠ¤íƒ€ / í‹±í†¡ ì†Œì…œ ê²€ìƒ‰ ë§í¬ -->
            <div class="mt-2 social-link-row" id="social-link-row" style="display:none;">
                <div class="row g-1">
                    <div class="col-4 text-center">
                        <a id="ytLink" href="#" target="_blank" class="btn btn-sm w-100 btn-outline-danger">ğŸ”´ ìœ íŠœë¸Œì—ì„œ ê²€ìƒ‰</a>
                    </div>
                    <div class="col-4 text-center">
                        <a id="igLink" href="#" target="_blank" class="btn btn-sm w-100 btn-outline-primary">ğŸ“¸ ì¸ìŠ¤íƒ€ íƒœê·¸</a>
                    </div>
                    <div class="col-4 text-center">
                        <a id="ttLink" href="#" target="_blank" class="btn btn-sm w-100 btn-outline-dark">ğŸµ í‹±í†¡ íƒœê·¸</a>
                    </div>
                </div>
                <small class="text-muted">í˜„ì¬ ì…ë ¥í•œ ê²€ìƒ‰ì–´ ê¸°ì¤€ìœ¼ë¡œ ê°ê° ìƒˆ ì°½ì—ì„œ ì—´ë¦½ë‹ˆë‹¤.</small>
            </div>
        </div>

        <!-- API í‚¤ ì˜ì—­ -->
        <div class="col-md-3 text-center">
            <p>API ì—°ë™ ìƒíƒœ: <span id="api-conn-badge" class="badge bg-secondary">API í‚¤ ë¯¸ë“±ë¡</span></p>
            <div class="input-group input-group-sm mb-2">
                <input id="apiKeyInput" type="password" class="form-control" placeholder="ë³¸ì¸ YouTube API í‚¤ ì…ë ¥">
                <button id="saveApiKeyBtn" class="btn btn-outline-primary">ì €ì¥/ë³€ê²½</button>
                <button id="clearApiKeyBtn" class="btn btn-outline-danger">í•´ì œ</button>
            </div>
            <small id="apiKeyStatus" class="text-muted d-block">
                ì´ ë¸Œë¼ìš°ì €ì— ì €ì¥ëœ ë³¸ì¸ API í‚¤ë¥¼ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤.
            </small>
        </div>
    </div>

    <hr>

    <!-- ì¹´í…Œê³ ë¦¬ ë²„íŠ¼ -->
    <div class="text-center">
        <button class="btn btn-outline-danger category-button active" data-category="All">ğŸ“Œ ì „ì²´ ì˜ìƒ</button>
        <button class="btn btn-outline-secondary category-button" data-category="Music">ğŸ¶ ìŒì•…/ëŒ„ìŠ¤</button>
        <button class="btn btn-outline-secondary category-button" data-category="Entertainment">ğŸ¬ ì½”ë¯¸ë””/ì˜¤ë½</button>
        <button class="btn btn-outline-secondary category-button" data-category="Sports">ğŸ€ ìŠ¤í¬ì¸ </button>
        <button class="btn btn-outline-secondary category-button" data-category="Vlog">ğŸ“¸ Vlog/ì¼ìƒ</button>
        <button class="btn btn-outline-secondary category-button" data-category="Education">ğŸ“š êµìœ¡/ì§€ì‹</button>
        <button class="btn btn-outline-secondary category-button" data-category="IT">ğŸ’» IT/í…Œí¬</button>
        <button class="btn btn-outline-secondary category-button" data-category="News">ğŸ“° ë‰´ìŠ¤/ì •ì¹˜</button>
        <button class="btn btn-outline-secondary category-button" data-category="Live">ğŸ“¡ ë¼ì´ë¸Œ</button>
    </div>

    <!-- í•„í„° ë°” -->
    <div class="text-center filter-bar">
        <!-- ê¸¸ì´ í•„í„° -->
        <div class="btn-group btn-group-sm" role="group" aria-label="Duration filter">
            <button class="btn btn-outline-dark duration-button active" data-duration="all">ì „ì²´ ê¸¸ì´</button>
            <button class="btn btn-outline-dark duration-button" data-duration="short">1ë¶„ ì´í•˜</button>
            <button class="btn btn-outline-dark duration-button" data-duration="mid">1~10ë¶„</button>
            <button class="btn btn-outline-dark duration-button" data-duration="long">10ë¶„ ì´ìƒ</button>
        </div>

        <!-- ì •ë ¬ í•„í„° -->
        <div class="btn-group btn-group-sm" role="group" aria-label="View sort">
            <button class="btn btn-outline-secondary sort-button active" data-sort="viewsDesc">ì¡°íšŒìˆ˜ ë†’ì€ ìˆœ</button>
            <button class="btn btn-outline-secondary sort-button" data-sort="viewsAsc">ì¡°íšŒìˆ˜ ë‚®ì€ ìˆœ</button>
            <button class="btn btn-outline-secondary sort-button" data-sort="viewsPerHourDesc">ì¡°íšŒ ì†ë„ ìˆœ</button>
            <button class="btn btn-outline-secondary sort-button" data-sort="likeRateDesc">ì¢‹ì•„ìš”ìœ¨ ìˆœ</button>
        </div>

        <!-- ê¸°ê°„ í•„í„° -->
        <div class="btn-group btn-group-sm" role="group" aria-label="Time range filter">
            <button class="btn btn-outline-secondary time-range-button active" data-range="r1">ìµœê·¼ 48ì‹œê°„</button>
            <button class="btn btn-outline-secondary time-range-button" data-range="r2">48ì‹œê°„~1ì£¼</button>
            <button class="btn btn-outline-secondary time-range-button" data-range="r3">1ì£¼~1ë‹¬</button>
            <button class="btn btn-outline-secondary time-range-button" data-range="r4">1ë‹¬~6ê°œì›”</button>
            <button class="btn btn-outline-secondary time-range-button" data-range="r5">6ê°œì›”~1ë…„</button>
            <button class="btn btn-outline-secondary time-range-button" data-range="r6">1ë…„ ì´ìƒ</button>
        </div>
    </div>

    <!-- êµ¬ë…ì í•„í„° -->
    <div class="text-center mt-2">
        <span class="text-muted me-2">êµ¬ë…ì ìˆ˜ í•„í„°:</span>
        <div class="form-check form-check-inline">
            <input class="form-check-input subscriber-filter-checkbox" type="checkbox" id="subFilterAll" data-range="all" checked>
            <label class="form-check-label" for="subFilterAll">ì „ì²´</label>
        </div>
        <div class="form-check form-check-inline">
            <input class="form-check-input subscriber-filter-checkbox" type="checkbox" id="subFilter1_1000" data-range="sub_1_1000">
            <label class="form-check-label" for="subFilter1_1000">1 ~ 1,000ëª…</label>
        </div>
        <div class="form-check form-check-inline">
            <input class="form-check-input subscriber-filter-checkbox" type="checkbox" id="subFilter1000_10000" data-range="sub_1000_10000">
            <label class="form-check-label" for="subFilter1000_10000">1,000 ~ 1ë§Œëª…</label>
        </div>
        <div class="form-check form-check-inline">
            <input class="form-check-input subscriber-filter-checkbox" type="checkbox" id="subFilter10000_40000" data-range="sub_10000_40000">
            <label class="form-check-label" for="subFilter10000_40000">1ë§Œ ~ 4ë§Œëª…</label>
        </div>
        <div class="form-check form-check-inline">
            <input class="form-check-input subscriber-filter-checkbox" type="checkbox" id="subFilter50000_plus" data-range="sub_50000_plus">
            <label class="form-check-label" for="subFilter50000_plus">5ë§Œ ì´ìƒ</label>
        </div>
    </div>

    <!-- â­ ì¦ê²¨ì°¾ê¸° ì˜ì—­ -->
    <div class="container mt-2">
        <div class="favorite-section">
            <div class="favorite-section-title">â­ ë‚˜ë§Œì˜ ì¦ê²¨ì°¾ê¸° í‚¤ì›Œë“œ ê·¸ë£¹</div>
            <div class="row g-1 align-items-center">
                <div class="col-md-3 col-12">
                    <input id="favGroupName" type="text" class="form-control form-control-sm" placeholder="ëŒ€íƒœê·¸ ì´ë¦„ (ì˜ˆ: ì—¬ìº )">
                </div>
                <div class="col-md-7 col-12">
                    <input id="favKeywords" type="text" class="form-control form-control-sm" placeholder="ì†Œíƒœê·¸(í‚¤ì›Œë“œ) ì‰¼í‘œ/ë„ì–´ì“°ê¸°ë¡œ êµ¬ë¶„ (ì˜ˆ: íƒœì—°, íƒì¬í›ˆ)">
                </div>
                <div class="col-md-2 col-12 d-grid">
                    <button id="addFavBtn" class="btn btn-sm btn-outline-warning">ì¶”ê°€/ì—…ë°ì´íŠ¸</button>
                </div>
            </div>
            <div id="favorite-buttons" class="mt-2">
                <small class="text-muted">ë“±ë¡ëœ ì¦ê²¨ì°¾ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.</small>
            </div>
        </div>
    </div>
</div>

<!-- ë©”ì¸ ì»¨í…ì¸  -->
<div class="container main-content">
    <div class="row">
        <!-- ì™¼ìª½ ì˜ìƒ ì˜ì—­ : 8 -->
        <div class="col-lg-8 col-md-8">
            <h4 id="category-title">ğŸ“Œ ì „ì²´ ì˜ìƒ</h4>
            <p class="text-muted" id="api-status">API í˜¸ì¶œ ì¤€ë¹„ ì¤‘...</p>
            <p class="text-muted" id="time-info">ê¸°ì¤€: ìµœê·¼ 48ì‹œê°„ ì´ë‚´ ì—…ë¡œë“œëœ ì¸ê¸° ì˜ìƒë§Œ í‘œì‹œ (ê°€ëŠ¥í•œ ê²½ìš°)</p>
            <div class="row" id="video-list"></div>
        </div>

        <!-- ì˜¤ë¥¸ìª½: íŠ¸ë Œë“œ í‚¤ì›Œë“œë§Œ -->
        <div class="col-lg-4 col-md-4">
            <div class="trend-box">
                <h5>ğŸ”¥ ì‹¤ì‹œê°„ íŠ¸ë Œë“œ í‚¤ì›Œë“œ TOP 30</h5>
                <p class="text-muted trend-meta mb-1" id="trend-region-info">ì§€ì—­: KR ê¸°ì¤€</p>
                <p class="text-muted trend-meta mb-2" id="trend-updated-time">
                    ê¸°ì¤€: í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ì¸ê¸° ì˜ìƒ(ì„ íƒí•œ ê¸°ê°„ ê¸°ì¤€)ì—ì„œ ìë™ ì¶”ì¶œ
                </p>
                <ol id="trend-keyword-list" class="trend-list">
                    <li><span class="trend-keyword">ë°ì´í„° ë¡œë”© ì¤‘...</span></li>
                </ol>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    let API_KEY = null;
    const BASE_URL = 'https://www.googleapis.com/youtube/v3/';
    const CATEGORIES = {
        'All': '',
        'Music': '10',
        'Entertainment': '24',
        'Sports': '17',
        'Vlog': '22',
        'Education': '27',
        'IT': '28',
        'News': '25',
        'Live': 'LIVE'
    };
    const ALL_CATEGORY_IDS = ['10','24','17','22','27','28','25'];

    let currentCategory = 'All';
    let currentBaseVideos = [];
    let currentChannelStatsMap = {};
    let currentSearchKeyword = '';
    let currentDurationFilter = 'all';
    let currentSortMode = 'viewsDesc';
    let currentTrendKeywords = [];
    let currentSubscriberRanges = new Set(['all']);
    let currentTimeRange = 'r1';

    // ì¦ê²¨ì°¾ê¸° ê·¸ë£¹
    let favoriteGroups = {};

    const STOPWORDS_COMMON = new Set([
        'official','video','music','mv','the','and','for','with','from','feat','live','of','in','on',
        'ë°©ì†¡','ì˜ìƒ','ê³µì‹','ì±„ë„','í‹°ë¹„','tv','full','ver','version','officialmv','shorts','ì‡¼ì¸ ',
        'ep','part','ì¬ì—…','í•˜ì´ë¼ì´íŠ¸','í’€ë²„ì „','í´ë¦½','clip','gameplay','highlight','ë‰´ìŠ¤','ë‹¨ë…'
    ]);
    const STOPWORDS_KO = new Set(['ì˜¤ëŠ˜','ì–´ì œ','ì´ë²ˆ','ì´ê²ƒ','ì €ê²ƒ','ìš°ë¦¬','ë‹¹ì‹ ','ì˜ìƒ','ì±„ë„','ê³µì‹','í•©ë‹ˆë‹¤','í•©ë‹ˆë‹¤ë§Œ','í•©ë‹ˆë‹¤ìš”','ì…ë‹ˆë‹¤','ê·¸ëƒ¥','ì˜ìƒì…ë‹ˆë‹¤','ì˜ìƒë³´ê¸°']);
    const STOPWORDS_EN = new Set(['a','an','is','it','this','that','you','me','we','they','are','to','at','by','as','be','my','your','our','their','new','official','feat','ft']);
    const STOPWORDS_JA = new Set(['ã®','ã«','ã‚’','ãŒ','ã¨','ã§','ã§ã™','ã¾ã™','ã™ã‚‹','ã—ãŸ','ã—ã¦','ã‹ã‚‰','ã¾ã§','ã•ã‚“','ã¡ã‚ƒã‚“','ãã‚“','å…¬å¼','æ˜ åƒ']);

    function formatNumberKR(num) {
        if (num == null || isNaN(num)) return '0';
        num = Number(num);
        if (num >= 100000000) {
            const eok = num / 100000000;
            const str = (eok >= 10 ? eok.toFixed(0) : eok.toFixed(1)).replace(/\.0$/, '');
            return str + 'ì–µ';
        }
        if (num >= 10000) return Math.round(num / 10000) + 'ë§Œ';
        if (num >= 1000) return Math.round(num / 1000) + 'ì²œ';
        return num.toString();
    }
    function formatNumber(num) { return formatNumberKR(num); }

    function timeAgo(publishedAt) {
        const now = new Date();
        const published = new Date(publishedAt);
        const diffMs = now - published;
        const diffMinutes = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        if (diffMinutes < 1) return 'ë°©ê¸ˆ ì „';
        if (diffHours < 1) return `${diffMinutes}ë¶„ ì „`;
        if (diffHours < 48) return `${diffHours}ì‹œê°„ ì „`;
        const diffDays = Math.floor(diffHours / 24);
        return `${diffDays}ì¼ ì „`;
    }

    function parseDurationSeconds(iso) {
        if (!iso) return 0;
        const match = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
        if (!match) return 0;
        const hours = parseInt(match[1] || '0');
        const minutes = parseInt(match[2] || '0');
        const seconds = parseInt(match[3] || '0');
        return hours * 3600 + minutes * 60 + seconds;
    }
    function formatDurationLabel(totalSeconds) {
        if (!totalSeconds || totalSeconds <= 0) return '';
        const h = Math.floor(totalSeconds / 3600);
        const m = Math.floor((totalSeconds % 3600) / 60);
        const s = totalSeconds % 60;
        if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        return `${m}:${String(s).padStart(2, '0')}`;
    }

    function getRegionAndLanguage() {
        const kr = document.getElementById('langKR').checked;
        const en = document.getElementById('langEN').checked;
        const jp = document.getElementById('langJP').checked;
        if (kr) return { regionCode: 'KR', relevanceLanguage: 'ko' };
        if (en) return { regionCode: 'US', relevanceLanguage: 'en' };
        if (jp) return { regionCode: 'JP', relevanceLanguage: 'ja' };
        return { regionCode: 'KR', relevanceLanguage: 'ko' };
    }

    // ê¸°ê°„ ì„¤ì •
    function getTimeRangeConfig() {
        const now = new Date();
        const hour = 60 * 60 * 1000;
        const day = 24 * hour;
        switch (currentTimeRange) {
            case 'r1': return { after: new Date(now.getTime() - 48 * hour), before: null, label: 'ìµœê·¼ 48ì‹œê°„ ì´ë‚´' };
            case 'r2': return { after: new Date(now.getTime() - 7 * day), before: new Date(now.getTime() - 48 * hour), label: '48ì‹œê°„ ~ 1ì£¼ì¼ ì „' };
            case 'r3': return { after: new Date(now.getTime() - 30 * day), before: new Date(now.getTime() - 7 * day), label: '1ì£¼ì¼ ~ 1ë‹¬ ì „' };
            case 'r4': return { after: new Date(now.getTime() - 180 * day), before: new Date(now.getTime() - 30 * day), label: '1ë‹¬ ~ 6ê°œì›” ì „' };
            case 'r5': return { after: new Date(now.getTime() - 365 * day), before: new Date(now.getTime() - 180 * day), label: '6ê°œì›” ~ 1ë…„ ì „' };
            case 'r6': return { after: null, before: new Date(now.getTime() - 365 * day), label: '1ë…„ ì´ìƒ (1ë…„ ì´ì „ ì—…ë¡œë“œ)' };
            default:   return { after: new Date(now.getTime() - 48 * hour), before: null, label: 'ìµœê·¼ 48ì‹œê°„ ì´ë‚´' };
        }
    }

    function filterVideosByTimeRange(videos) {
        const { after, before } = getTimeRangeConfig();
        if (!after && !before) return videos;
        return videos.filter(v => {
            const publishedAt = new Date(v.snippet.publishedAt);
            if (after && publishedAt < after) return false;
            if (before && publishedAt > before) return false;
            return true;
        });
    }

    /* -----------------------------
       ğŸ”‘ API í‚¤ ì €ì¥/ë¡œë“œ/í•´ì œ (ë¸Œë¼ìš°ì €ì— ì˜êµ¬ ì €ì¥: localStorage)
       - í•œ ë²ˆ ì €ì¥í•˜ë©´ ê°™ì€ ë¸Œë¼ìš°ì €ì—ì„œ í•´ì œ ì „ê¹Œì§€ ê³„ì† ì‚¬ìš©
       - localStorage ë§‰íŒ í™˜ê²½(ì‚¬íŒŒë¦¬ í”„ë¼ì´ë¹— ë“±)ì—ì„œë„ "ì´ë²ˆ ë¡œë”© ë™ì•ˆ"ì€ ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ fallback
    ----------------------------- */
    const API_KEY_STORAGE_KEY = 'ytTrendApiKey';
    let _storageMode = 'localStorage'; // 'localStorage' | 'memory'
    let _memoryKey = null;

    function getStorage() {
        try {
            // localStorage ì‚¬ìš© ê°€ëŠ¥ ì²´í¬
            const t = '__yttrend_test__';
            window.localStorage.setItem(t, '1');
            window.localStorage.removeItem(t);
            _storageMode = 'localStorage';
            return window.localStorage;
        } catch (e) {
            _storageMode = 'memory';
            return null;
        }
    }

    function loadApiKey() {
        const apiConnBadge = document.getElementById('api-conn-badge');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const apiKeyInput = document.getElementById('apiKeyInput');

        const st = getStorage();
        const savedKey = st ? st.getItem(API_KEY_STORAGE_KEY) : _memoryKey;

        if (savedKey && savedKey.trim() !== '') {
            API_KEY = savedKey.trim();
            apiConnBadge.className = 'badge bg-success';
            apiConnBadge.textContent = 'API í‚¤ ë“±ë¡ë¨';

            apiKeyStatus.textContent =
                (_storageMode === 'localStorage')
                    ? 'ì´ ë¸Œë¼ìš°ì €ì— ì €ì¥ëœ ë³¸ì¸ API í‚¤ë¥¼ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤. (í•´ì œ ì „ê¹Œì§€ ìœ ì§€)'
                    : 'ë¸Œë¼ìš°ì € ì„¤ì •ìœ¼ë¡œ ì €ì¥ì†Œ ì ‘ê·¼ì´ ë§‰í˜€ ë©”ëª¨ë¦¬ë¡œë§Œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤. (ìƒˆë¡œê³ ì¹¨/ì¬ì‹œì‘ ì‹œ ì´ˆê¸°í™”)';

            if (apiKeyInput) apiKeyInput.value = '';
        } else {
            API_KEY = null;
            apiConnBadge.className = 'badge bg-secondary';
            apiConnBadge.textContent = 'API í‚¤ ë¯¸ë“±ë¡';
            apiKeyStatus.textContent = 'ìƒë‹¨ ì…ë ¥ì°½ì— ë³¸ì¸ API í‚¤ë¥¼ ì €ì¥í•´ ì£¼ì„¸ìš”.';
        }
    }

    function saveApiKey() {
        const apiKeyInput = document.getElementById('apiKeyInput');
        const newKey = (apiKeyInput.value || '').trim();
        const apiConnBadge = document.getElementById('api-conn-badge');
        const apiKeyStatus = document.getElementById('apiKeyStatus');

        if (!newKey) {
            alert('API í‚¤ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”.');
            return;
        }

        API_KEY = newKey;

        const st = getStorage();
        if (st) {
            st.setItem(API_KEY_STORAGE_KEY, newKey);
            apiKeyStatus.textContent = 'ì´ ë¸Œë¼ìš°ì €ì— ì €ì¥ëœ ë³¸ì¸ API í‚¤ë¥¼ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤. (í•´ì œ ì „ê¹Œì§€ ìœ ì§€)';
        } else {
            _memoryKey = newKey;
            apiKeyStatus.textContent = 'ë¸Œë¼ìš°ì € ì„¤ì •ìœ¼ë¡œ ì €ì¥ì†Œ ì ‘ê·¼ì´ ë§‰í˜€ ë©”ëª¨ë¦¬ë¡œë§Œ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤. (ìƒˆë¡œê³ ì¹¨/ì¬ì‹œì‘ ì‹œ ì´ˆê¸°í™”)';
        }

        apiConnBadge.className = 'badge bg-success';
        apiConnBadge.textContent = 'API í‚¤ ë“±ë¡ë¨';
        apiKeyInput.value = '';

        alert(st
            ? 'API í‚¤ê°€ ì €ì¥/ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤. (ì´ ë¸Œë¼ìš°ì €ì—ì„œ í•´ì œ ì „ê¹Œì§€ ìœ ì§€ë©ë‹ˆë‹¤)'
            : 'API í‚¤ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤. (ì €ì¥ì´ ë§‰í˜€ ì´ë²ˆ ì‹¤í–‰ ë™ì•ˆë§Œ ìœ ì§€ë©ë‹ˆë‹¤)'
        );
    }

    function clearApiKey() {
        const st = getStorage();
        try {
            if (st) st.removeItem(API_KEY_STORAGE_KEY);
        } catch (e) { /* ignore */ }
        _memoryKey = null;
        API_KEY = null;

        const apiConnBadge = document.getElementById('api-conn-badge');
        const apiKeyStatus = document.getElementById('apiKeyStatus');

        apiConnBadge.className = 'badge bg-secondary';
        apiConnBadge.textContent = 'API í‚¤ ë¯¸ë“±ë¡';
        apiKeyStatus.textContent = 'ìƒë‹¨ ì…ë ¥ì°½ì— ë³¸ì¸ API í‚¤ë¥¼ ì €ì¥í•´ ì£¼ì„¸ìš”.';

        document.getElementById('video-list').innerHTML = '';
        document.getElementById('api-status').textContent = 'API í‚¤ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‚¬ìš©í•˜ë ¤ë©´ API í‚¤ë¥¼ ë“±ë¡í•´ ì£¼ì„¸ìš”.';
        document.getElementById('trend-keyword-list').innerHTML = '<li><span class="trend-keyword">API í‚¤ë¥¼ ë¨¼ì € ë“±ë¡í•´ ì£¼ì„¸ìš”.</span></li>';

        alert('API í‚¤ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
    /* ----------------------------- */

    function getFriendlyErrorMessage(errorObj, contextText) {
        const reason = errorObj?.errors?.[0]?.reason || '';
        const message = errorObj?.message || '';
        let prefix = contextText || 'API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        switch (reason) {
            case 'quotaExceeded':
                return `${prefix}<br>âš ï¸ ì˜¤ëŠ˜ YouTube API ì¿¼í„°ë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.`;
            case 'accessNotConfigured':
                return `${prefix}<br>âš ï¸ YouTube Data API v3 ì‚¬ìš© ì„¤ì •ì´ ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.`;
            case 'ipRefererBlocked':
            case 'dailyLimitExceeded':
            case 'keyInvalid':
            case 'forbidden':
                return `${prefix}<br>âš ï¸ API í‚¤ ì„¤ì •(ë„ë©”ì¸/IP/ìœ íš¨ì„±)ì„ í™•ì¸í•´ ì£¼ì„¸ìš”.`;
            default:
                return `${prefix}<br>(${message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ì…ë‹ˆë‹¤.'})`;
        }
    }

    async function fetchMostPopularForCategory(regionCode, categoryId) {
        let url = `${BASE_URL}videos?part=snippet,contentDetails,statistics&chart=mostPopular&regionCode=${regionCode}&maxResults=50&key=${API_KEY}`;
        if (categoryId) url += `&videoCategoryId=${categoryId}`;
        const response = await fetch(url);
        const data = await response.json();
        if (data.error) throw { ytError: data.error };
        return data.items || [];
    }

    // Music ì¹´í…Œê³ ë¦¬ ìµœì í™”: search APIë¡œ ìµœê·¼ ì˜ìƒ í•„í„°ë§ ì§€ì›
    async function fetchMusicVideos(regionCode, categoryId, timeConfig) {
        const { after, before } = timeConfig;
        let searchUrl = `${BASE_URL}search?part=snippet&type=video&maxResults=50&order=viewCount&regionCode=${regionCode}&videoCategoryId=${categoryId}&key=${API_KEY}`;
        if (after) searchUrl += `&publishedAfter=${after.toISOString()}`;
        if (before) searchUrl += `&publishedBefore=${before.toISOString()}`;
        const searchResp = await fetch(searchUrl);
        const searchData = await searchResp.json();
        if (searchData.error) throw { ytError: searchData.error };
        const items = searchData.items || [];
        if (items.length === 0) return [];
        const videoIds = items.map(it => it.id && it.id.videoId).filter(Boolean);
        const videosUrl = `${BASE_URL}videos?part=snippet,contentDetails,statistics&id=${videoIds.join(',')}&key=${API_KEY}`;
        const videosResp = await fetch(videosUrl);
        const videosData = await videosResp.json();
        if (videosData.error) throw { ytError: videosData.error };
        return videosData.items || [];
    }

    async function fetchPopularVideos(categoryId) {
        const videoListDiv = document.getElementById('video-list');
        const apiStatusP = document.getElementById('api-status');
        const apiConnBadge = document.getElementById('api-conn-badge');

        if (!API_KEY) {
            videoListDiv.innerHTML = '';
            apiStatusP.textContent = 'ë¨¼ì € ìƒë‹¨ì—ì„œ ë³¸ì¸ YouTube API í‚¤ë¥¼ ë“±ë¡í•´ ì£¼ì„¸ìš”.';
            apiConnBadge.className = 'badge bg-secondary';
            apiConnBadge.textContent = 'API í‚¤ ë¯¸ë“±ë¡';
            return;
        }

        videoListDiv.innerHTML = '';
        apiStatusP.textContent = 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...';
        apiConnBadge.className = 'badge bg-warning text-dark';
        apiConnBadge.textContent = 'ìš”ì²­ ì¤‘...';

        const { regionCode } = getRegionAndLanguage();
        const timeConfig = getTimeRangeConfig();
        updateTrendRegionInfo();

        try {
            let allItems = [];

            if (!categoryId) {
                const results = await Promise.allSettled(
                    ALL_CATEGORY_IDS.map(id => fetchMostPopularForCategory(regionCode, id))
                );
                let firstError = null;

                results.forEach(r => {
                    if (r.status === 'fulfilled') {
                        if (Array.isArray(r.value)) allItems = allItems.concat(r.value);
                    } else {
                        if (!firstError && r.reason?.ytError) firstError = r.reason;
                        console.warn('ì¹´í…Œê³ ë¦¬ë³„ í˜¸ì¶œ ì‹¤íŒ¨(ë¬´ì‹œ):', r.reason);
                    }
                });

                if (allItems.length === 0 && firstError) throw firstError;
            } else if (categoryId === '10' && timeConfig.after) {
                allItems = await fetchMusicVideos(regionCode, categoryId, timeConfig);
            } else {
                const arr = await fetchMostPopularForCategory(regionCode, categoryId);
                allItems = allItems.concat(arr);
            }

            if (allItems.length === 0) {
                currentBaseVideos = [];
                currentChannelStatsMap = {};
                renderVideoList([], {});
                updateTrendKeywords([]);
                apiStatusP.textContent = 'í‘œì‹œí•  ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤. (ì´ ì¹´í…Œê³ ë¦¬/ì§€ì—­ì—ì„œ ì¸ê¸° ì˜ìƒì´ ì—†ê±°ë‚˜ API ì¿¼í„° ì œí•œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤)';
                document.getElementById('time-info').textContent = 'ê¸°ì¤€: ì„ íƒí•œ ê¸°ê°„ì— í•´ë‹¹í•˜ëŠ” ì¸ê¸° ì˜ìƒì´ ì—†ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                apiConnBadge.className = 'badge bg-warning text-dark';
                apiConnBadge.textContent = 'ë°ì´í„° ì—†ìŒ';
                currentSearchKeyword = '';
                return;
            }

            // ì¤‘ë³µ ì œê±°
            const uniqueMap = new Map();
            allItems.forEach(v => {
                const vid = v.id;
                if (!uniqueMap.has(vid)) uniqueMap.set(vid, v);
            });

            let combinedItems = Array.from(uniqueMap.values());
            combinedItems.sort((a, b) => {
                const va = parseInt(a.statistics?.viewCount || '0', 10);
                const vb = parseInt(b.statistics?.viewCount || '0', 10);
                return vb - va;
            });

            let withinRange = filterVideosByTimeRange(combinedItems);
            const timeInfoEl = document.getElementById('time-info');
            const { label } = timeConfig;

            if (withinRange.length === 0) {
                withinRange = combinedItems;
                if (timeInfoEl) {
                    timeInfoEl.textContent =
                        (categoryId === '10')
                            ? 'âš ï¸ ìµœê·¼ Music íŠ¸ë Œë“œê°€ ì ì–´ ì „ì²´ ì¸ê¸° ì˜ìƒ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤. (ì‹ ê³¡ ì—…ë°ì´íŠ¸ í™•ì¸)'
                            : 'âš ï¸ ì„ íƒí•œ ê¸°ê°„ì— í•´ë‹¹í•˜ëŠ” ì¸ê¸° ì˜ìƒì´ ê±°ì˜ ì—†ì–´ ì „ì²´ ì¸ê¸° ì˜ìƒ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.';
                }
            } else {
                if (timeInfoEl) timeInfoEl.textContent = `ê¸°ì¤€: ${label} ì—…ë¡œë“œëœ ì¸ê¸° ì˜ìƒë§Œ í‘œì‹œ ì¤‘ì…ë‹ˆë‹¤.`;
            }

            currentBaseVideos = withinRange;
            currentSearchKeyword = '';

            const channelStatsMap = await fetchChannelStats(withinRange);
            currentChannelStatsMap = channelStatsMap;

            updateVideoListAndStatus();
            buildAndRenderTrendKeywords();

            apiConnBadge.className = 'badge bg-success';
            apiConnBadge.textContent = 'API ì—°ê²° ì •ìƒ';

        } catch (error) {
            console.error('API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            if (error.ytError) {
                apiStatusP.innerHTML = getFriendlyErrorMessage(error.ytError, 'âš ï¸ ì¸ê¸° ì˜ìƒ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } else {
                apiStatusP.innerHTML = 'âš ï¸ API í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.<br>API í‚¤/ì¿¼í„°/ë¦¬í¼ëŸ¬(ë„ë©”ì¸) ì œí•œì„ í™•ì¸í•´ ì£¼ì„¸ìš”.';
            }
            apiConnBadge.className = 'badge bg-danger';
            apiConnBadge.textContent = 'ì˜¤ë¥˜';
            updateTrendKeywords([]);
        }
    }

    async function fetchLiveVideos() {
        const videoListDiv = document.getElementById('video-list');
        const apiStatusP = document.getElementById('api-status');
        const apiConnBadge = document.getElementById('api-conn-badge');

        if (!API_KEY) {
            videoListDiv.innerHTML = '';
            apiStatusP.textContent = 'ë¨¼ì € ìƒë‹¨ì—ì„œ ë³¸ì¸ YouTube API í‚¤ë¥¼ ë“±ë¡í•´ ì£¼ì„¸ìš”.';
            apiConnBadge.className = 'badge bg-secondary';
            apiConnBadge.textContent = 'API í‚¤ ë¯¸ë“±ë¡';
            return;
        }

        videoListDiv.innerHTML = '';
        apiStatusP.textContent = 'ë¼ì´ë¸Œ ë°©ì†¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤...';
        apiConnBadge.className = 'badge bg-warning text-dark';
        apiConnBadge.textContent = 'ìš”ì²­ ì¤‘...';

        const { regionCode } = getRegionAndLanguage();
        updateTrendRegionInfo();

        try {
            const searchUrl =
                `${BASE_URL}search?part=snippet&type=video&maxResults=50` +
                `&order=viewCount&regionCode=${regionCode}` +
                `&eventType=live&key=${API_KEY}`;

            const searchResp = await fetch(searchUrl);
            const searchData = await searchResp.json();
            if (searchData.error) throw { ytError: searchData.error };

            const items = searchData.items || [];
            if (items.length === 0) {
                currentBaseVideos = [];
                currentChannelStatsMap = {};
                renderVideoList([], {});
                updateTrendKeywords([]);
                apiStatusP.textContent = 'í˜„ì¬ ì´ ì§€ì—­ì—ì„œ ì¸ê¸° ë¼ì´ë¸Œ ë°©ì†¡ì´ ì—†ìŠµë‹ˆë‹¤.';
                document.getElementById('time-info').textContent = 'ë¼ì´ë¸Œ ë°©ì†¡ ì—†ìŒ.';
                apiConnBadge.className = 'badge bg-warning text-dark';
                apiConnBadge.textContent = 'ë¼ì´ë¸Œ 0ê°œ';
                currentSearchKeyword = '';
                return;
            }

            const videoIds = items.map(it => it.id && it.id.videoId).filter(Boolean);
            const videosUrl =
                `${BASE_URL}videos?part=snippet,contentDetails,statistics` +
                `&id=${videoIds.join(',')}&key=${API_KEY}`;

            const videosResp = await fetch(videosUrl);
            const videosData = await videosResp.json();
            if (videosData.error) throw { ytError: videosData.error };

            let videoItems = videosData.items || [];
            videoItems.sort((a, b) => {
                const va = parseInt(a.statistics?.viewCount || '0', 10);
                const vb = parseInt(b.statistics?.viewCount || '0', 10);
                return vb - va;
            });

            currentBaseVideos = videoItems;
            currentSearchKeyword = '';

            const channelStatsMap = await fetchChannelStats(videoItems);
            currentChannelStatsMap = channelStatsMap;

            document.getElementById('time-info').textContent =
                'ê¸°ì¤€: í˜„ì¬ ë¼ì´ë¸Œ ë°©ì†¡ ì¤‘ì¸ ì˜ìƒ(ì¡°íšŒìˆ˜ ë†’ì€ ìˆœ)ì„ í‘œì‹œí•©ë‹ˆë‹¤. (ê¸°ê°„ í•„í„°ëŠ” ë¼ì´ë¸Œì—ëŠ” ì ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤)';

            updateVideoListAndStatus();
            buildAndRenderTrendKeywords();

            apiConnBadge.className = 'badge bg-success';
            apiConnBadge.textContent = 'API ì—°ê²° ì •ìƒ';

        } catch (error) {
            console.error('ë¼ì´ë¸Œ API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            if (error.ytError) {
                apiStatusP.innerHTML = getFriendlyErrorMessage(error.ytError, 'âš ï¸ ë¼ì´ë¸Œ ë°©ì†¡ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            } else {
                apiStatusP.innerHTML = 'âš ï¸ ë¼ì´ë¸Œ API í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.<br>API í‚¤/ì¿¼í„°/ë¦¬í¼ëŸ¬(ë„ë©”ì¸) ì œí•œì„ í™•ì¸í•´ ì£¼ì„¸ìš”.';
            }
            apiConnBadge.className = 'badge bg-danger';
            apiConnBadge.textContent = 'ì˜¤ë¥˜';
            updateTrendKeywords([]);
        }
    }

    // ğŸ”— ì†Œì…œ ë§í¬
    function updateSocialLinks(keyword) {
        const row = document.getElementById('social-link-row');
        const yt = document.getElementById('ytLink');
        const ig = document.getElementById('igLink');
        const tt = document.getElementById('ttLink');
        if (!row || !yt || !ig || !tt) return;

        const trimmed = (keyword || '').trim();
        if (!trimmed) {
            row.style.display = 'none';
            yt.removeAttribute('href'); ig.removeAttribute('href'); tt.removeAttribute('href');
            return;
        }
        const tag = trimmed.replace(/^#/, '');
        const encoded = encodeURIComponent(tag);
        yt.href = `https://www.youtube.com/results?search_query=${encoded}`;
        ig.href = `https://www.instagram.com/explore/tags/${encoded}/`;
        tt.href = `https://www.tiktok.com/tag/${encoded}`;
        row.style.display = 'block';
    }

    async function searchVideosByKeyword(keyword) {
        const videoListDiv = document.getElementById('video-list');
        const apiStatusP = document.getElementById('api-status');
        const apiConnBadge = document.getElementById('api-conn-badge');

        updateSocialLinks(keyword);

        if (!API_KEY) {
            videoListDiv.innerHTML = '';
            apiStatusP.textContent = 'ë¨¼ì € ìƒë‹¨ì—ì„œ ë³¸ì¸ YouTube API í‚¤ë¥¼ ë“±ë¡í•´ ì£¼ì„¸ìš”.';
            apiConnBadge.className = 'badge bg-secondary';
            apiConnBadge.textContent = 'API í‚¤ ë¯¸ë“±ë¡';
            return;
        }

        videoListDiv.innerHTML = '';
        apiStatusP.textContent = `"${keyword}" ê²€ìƒ‰ ì¤‘...`;
        apiConnBadge.className = 'badge bg-warning text-dark';
        apiConnBadge.textContent = 'ê²€ìƒ‰ ì¤‘...';

        const { regionCode } = getRegionAndLanguage();
        updateTrendRegionInfo();

        try {
            const { after, before, label } = getTimeRangeConfig();
            const categoryId = CATEGORIES[currentCategory] || '';

            let searchBase =
                `${BASE_URL}search?part=snippet&type=video&maxResults=50&order=relevance` +
                `&regionCode=${regionCode}&q=${encodeURIComponent(keyword)}&key=${API_KEY}`;

            if (categoryId && currentCategory !== 'Live') searchBase += `&videoCategoryId=${categoryId}`;

            let timeQuery = '';
            if (after) timeQuery += `&publishedAfter=${after.toISOString()}`;
            if (before) timeQuery += `&publishedBefore=${before.toISOString()}`;

            let searchUrl = searchBase + timeQuery;
            let response = await fetch(searchUrl);
            let searchData = await response.json();
            if (searchData.error) throw { ytError: searchData.error };

            let items = searchData.items || [];
            if (items.length === 0 && timeQuery) {
                searchUrl = searchBase; // ê¸°ê°„ì¡°ê±´ ì—†ì´ ì¬ê²€ìƒ‰
                response = await fetch(searchUrl);
                searchData = await response.json();
                if (searchData.error) throw { ytError: searchData.error };
                items = searchData.items || [];
            }

            if (items.length === 0) {
                currentBaseVideos = [];
                currentChannelStatsMap = {};
                renderVideoList([], {});
                updateTrendKeywords([]);
                apiStatusP.textContent = `"${keyword}" ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.`;
                document.getElementById('time-info').textContent = 'ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ.';
                apiConnBadge.className = 'badge bg-warning text-dark';
                apiConnBadge.textContent = 'ê²€ìƒ‰ 0ê°œ';
                currentSearchKeyword = keyword;
                return;
            }

            const videoIds = items.map(it => it.id && it.id.videoId).filter(Boolean);
            const videosUrl =
                `${BASE_URL}videos?part=snippet,contentDetails,statistics&id=${videoIds.join(',')}&key=${API_KEY}`;

            const videosResp = await fetch(videosUrl);
            const videosData = await videosResp.json();
            if (videosData.error) throw { ytError: videosData.error };

            let videoItems = videosData.items || [];
            videoItems.sort((a, b) => {
                const va = parseInt(a.statistics?.viewCount || '0', 10);
                const vb = parseInt(b.statistics?.viewCount || '0', 10);
                return vb - va;
            });

            let withinRange = filterVideosByTimeRange(videoItems);
            const timeInfoEl = document.getElementById('time-info');

            if (withinRange.length === 0) {
                withinRange = videoItems;
                if (timeInfoEl) timeInfoEl.textContent = 'âš ï¸ ì„ íƒí•œ ê¸°ê°„ì— í•´ë‹¹í•˜ëŠ” ê²€ìƒ‰ ê²°ê³¼ê°€ ì ì–´ ì „ì²´ ê²€ìƒ‰ ê²°ê³¼ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.';
            } else {
                if (timeInfoEl) timeInfoEl.textContent = `ê¸°ì¤€: ${label} ì—…ë¡œë“œëœ ì˜ìƒ ì¤‘ "${keyword}" ê´€ë ¨ ì¸ê¸° ì˜ìƒë§Œ í‘œì‹œ ì¤‘ì…ë‹ˆë‹¤.`;
            }

            currentBaseVideos = withinRange;
            currentSearchKeyword = keyword;

            const channelStatsMap = await fetchChannelStats(withinRange);
            currentChannelStatsMap = channelStatsMap;

            updateVideoListAndStatus();
            buildAndRenderTrendKeywords();

            apiConnBadge.className = 'badge bg-success';
            apiConnBadge.textContent = 'ê²€ìƒ‰ ì™„ë£Œ';

        } catch (error) {
            console.error('ê²€ìƒ‰ API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            if (error.ytError) {
                apiStatusP.innerHTML = getFriendlyErrorMessage(error.ytError, `âš ï¸ "${keyword}" ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`);
            } else {
                apiStatusP.innerHTML = 'âš ï¸ ê²€ìƒ‰ API í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.<br>API í‚¤/ì¿¼í„°/ë¦¬í¼ëŸ¬(ë„ë©”ì¸) ì œí•œì„ í™•ì¸í•´ ì£¼ì„¸ìš”.';
            }
            apiConnBadge.className = 'badge bg-danger';
            apiConnBadge.textContent = 'ê²€ìƒ‰ ì˜¤ë¥˜';
            updateTrendKeywords([]);
        }
    }

    async function fetchChannelStats(videoItems) {
        const channelIds = Array.from(new Set(videoItems.map(v => v.snippet.channelId).filter(Boolean)));
        if (channelIds.length === 0) return {};

        const CHUNK_SIZE = 50;
        const map = {};

        for (let i = 0; i < channelIds.length; i += CHUNK_SIZE) {
            const chunk = channelIds.slice(i, i + CHUNK_SIZE);
            const url = `${BASE_URL}channels?part=statistics&id=${chunk.join(',')}&key=${API_KEY}`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.error) { console.error('ì±„ë„ ì •ë³´ í˜¸ì¶œ ì˜¤ë¥˜:', data.error); continue; }
                (data.items || []).forEach(ch => {
                    const id = ch.id;
                    const subs = ch.statistics.subscriberCount ? parseInt(ch.statistics.subscriberCount) : 0;
                    map[id] = subs;
                });
            } catch (e) {
                console.error('ì±„ë„ ì •ë³´ í˜¸ì¶œ ì˜¤ë¥˜:', e);
            }
        }
        return map;
    }

    function matchSubscriberRange(subscribers, rangeKey) {
        if (!subscribers || subscribers <= 0) return false;
        switch (rangeKey) {
            case 'sub_1_1000': return subscribers >= 1 && subscribers < 1000;
            case 'sub_1000_10000': return subscribers >= 1000 && subscribers < 10000;
            case 'sub_10000_40000': return subscribers >= 10000 && subscribers < 40000;
            case 'sub_50000_plus': return subscribers >= 50000;
            default: return true;
        }
    }

    function getFilteredVideos() {
        let list = currentBaseVideos.slice();

        // ê¸¸ì´ í•„í„° (Live ì œì™¸)
        if (currentDurationFilter !== 'all' && currentCategory !== 'Live') {
            list = list.filter(v => {
                const seconds = parseDurationSeconds(v.contentDetails?.duration || '');
                if (currentDurationFilter === 'short') return seconds > 0 && seconds <= 60;
                if (currentDurationFilter === 'mid') return seconds > 60 && seconds <= 600;
                if (currentDurationFilter === 'long') return seconds > 600;
                return true;
            });
        }

        // êµ¬ë…ì í•„í„°
        if (!(currentSubscriberRanges.size === 1 && currentSubscriberRanges.has('all'))) {
            list = list.filter(v => {
                const subs = currentChannelStatsMap[v.snippet.channelId] || 0;
                for (const rangeKey of currentSubscriberRanges) {
                    if (matchSubscriberRange(subs, rangeKey)) return true;
                }
                return false;
            });
        }

        // ì •ë ¬
        list.sort((a, b) => {
            const va = parseInt(a.statistics?.viewCount || '0', 10);
            const vb = parseInt(b.statistics?.viewCount || '0', 10);
            const la = parseInt(a.statistics?.likeCount || '0', 10);
            const lb = parseInt(b.statistics?.likeCount || '0', 10);

            const ta = new Date(a.snippet.publishedAt);
            const tb = new Date(b.snippet.publishedAt);

            const ha = Math.max((Date.now() - ta.getTime()) / (1000 * 60 * 60), 1 / 60);
            const hb = Math.max((Date.now() - tb.getTime()) / (1000 * 60 * 60), 1 / 60);

            const likeRateA = va > 0 ? la / va : 0;
            const likeRateB = vb > 0 ? lb / vb : 0;

            const speedA = va / ha;
            const speedB = vb / hb;

            switch (currentSortMode) {
                case 'viewsAsc': return va - vb;
                case 'likeRateDesc': return likeRateB - likeRateA;
                case 'viewsPerHourDesc': return speedB - speedA;
                case 'viewsDesc':
                default: return vb - va;
            }
        });

        return list;
    }

    function updateVideoListAndStatus() {
        const apiStatusP = document.getElementById('api-status');
        const list = getFilteredVideos();
        renderVideoList(list, currentChannelStatsMap);

        if (!apiStatusP) return;

        if (currentSearchKeyword) {
            apiStatusP.textContent = `"${currentSearchKeyword}" ê²€ìƒ‰ ê²°ê³¼: ${list.length}ê°œ`;
        } else if (currentCategory === 'Live') {
            apiStatusP.textContent = `í˜„ì¬ ë¼ì´ë¸Œ ë°©ì†¡: ${list.length}ê°œ`;
        } else {
            apiStatusP.textContent = `ì´ ${list.length}ê°œì˜ ì˜ìƒì„ í‘œì‹œí•©ë‹ˆë‹¤.`;
        }
    }

    function renderVideoList(videos, channelStatsMap = {}) {
        const videoListDiv = document.getElementById('video-list');
        videoListDiv.innerHTML = '';
        videos.forEach(video => { videoListDiv.innerHTML += createVideoCard(video, channelStatsMap); });
    }

    function createVideoCard(video, channelStatsMap) {
        const title = video.snippet.title;
        const channelTitle = video.snippet.channelTitle;
        const channelId = video.snippet.channelId;
        const videoId = video.id;
        const thumbnailUrl = video.snippet.thumbnails.medium.url;

        const viewCount = video.statistics.viewCount ? parseInt(video.statistics.viewCount) : 0;
        const likeCount = video.statistics.likeCount ? parseInt(video.statistics.likeCount) : 0;
        const commentCount = video.statistics.commentCount ? parseInt(video.statistics.commentCount) : 0;

        const subscriberCount = channelStatsMap[channelId] || 0;
        const publishedAt = video.snippet.publishedAt;

        const timeAgoText = timeAgo(publishedAt);

        const publishedDate = new Date(publishedAt);
        const hoursSinceUpload = Math.max((Date.now() - publishedDate.getTime()) / (1000 * 60 * 60), 1 / 60);
        const viewVelocity = viewCount > 0 ? viewCount / hoursSinceUpload : 0;

        const likeRate = viewCount > 0 ? (likeCount / viewCount) * 100 : 0;
        const commentRate = viewCount > 0 ? (commentCount / viewCount) * 100 : 0;

        const durationSeconds = parseDurationSeconds(video.contentDetails?.duration || '');
        const durationLabel = formatDurationLabel(durationSeconds);

        return `
        <div class="col-xl-2 col-lg-3 col-md-4 col-sm-6">
            <div class="video-card">
                <a href="https://www.youtube.com/watch?v=${videoId}" target="_blank" style="position:relative;display:block;">
                    <img src="${thumbnailUrl}" class="card-img-top" alt="${title}">
                    ${
                        durationLabel
                            ? `<span style="
                                position:absolute;
                                right:4px;
                                bottom:4px;
                                background:rgba(0,0,0,0.8);
                                color:#fff;
                                font-size:0.75rem;
                                padding:2px 4px;
                                border-radius:3px;
                            ">${durationLabel}</span>`
                            : ''
                    }
                </a>
                <div class="card-body">
                    <h5 class="card-title">${title}</h5>
                    <p class="card-text text-muted mb-1">${channelTitle}</p>
                    <p class="card-text"><span class="badge badge-time">${timeAgoText}</span></p>
                    <div>
                        <span class="stats-badge badge-views">${formatNumber(viewCount)} ì¡°íšŒ</span>
                        <span class="stats-badge badge-likes">${formatNumber(likeCount)} ì¢‹ì•„ìš”</span>
                        <span class="stats-badge badge-comments">${formatNumber(commentCount)} ëŒ“ê¸€</span>
                        <span class="stats-badge badge-subscribers">${formatNumber(subscriberCount)} êµ¬ë…</span>
                    </div>
                    <div class="mt-1">
                        <span class="stats-badge badge-velocity">${formatNumber(Math.round(viewVelocity))}íšŒ/ì‹œê°„</span>
                        <span class="stats-badge badge-likeRate">ì¢‹ì•„ìš”ìœ¨ ${likeRate.toFixed(1)}%</span>
                        <span class="stats-badge badge-commentRate">ëŒ“ê¸€ë¹„ìœ¨ ${commentRate.toFixed(2)}%</span>
                    </div>
                </div>
            </div>
        </div>`;
    }

    function tokenizeText(text) {
        if (!text) return [];
        return text.toLowerCase().split(/[^0-9a-zA-Zê°€-í£ã-ã‚“ã‚¡-ãƒ³ä¸€-é¾¯]+/g).filter(Boolean);
    }
    function isStopword(token) {
        if (!token) return true;
        if (STOPWORDS_COMMON.has(token)) return true;
        if (STOPWORDS_KO.has(token)) return true;
        if (STOPWORDS_EN.has(token)) return true;
        if (STOPWORDS_JA.has(token)) return true;
        return false;
    }
    function isValidToken(token) {
        if (!token) return false;
        if (token.length < 2) return false;
        if (/^\d+$/.test(token)) return false;
        if (isStopword(token)) return false;
        return true;
    }

    function buildTrendKeywordsFromVideos(videos) {
        const wordScoreMap = new Map();
        videos.forEach(video => {
            const title = video.snippet.title || '';
            const tags = video.snippet.tags || [];
            const views = parseInt(video.statistics?.viewCount || '0', 10);
            const weight = views > 0 ? Math.log10(views + 1) : 1;

            const text = title + ' ' + tags.join(' ') + ' ';
            const tokens = tokenizeText(text);
            const tokenSet = new Set(tokens);

            tokenSet.forEach(tok => {
                if (!isValidToken(tok)) return;
                const prev = wordScoreMap.get(tok) || 0;
                wordScoreMap.set(tok, prev + weight);
            });
        });

        return Array.from(wordScoreMap.entries())
            .map(([word, score]) => ({ word, score }))
            .sort((a, b) => b.score - a.score)
            .slice(0, 30);
    }

    function updateTrendRegionInfo() {
        const { regionCode } = getRegionAndLanguage();
        const infoEl = document.getElementById('trend-region-info');
        if (infoEl) infoEl.textContent = `ì§€ì—­: ${regionCode} ê¸°ì¤€`;
    }

    function updateTrendUpdatedTime() {
        const el = document.getElementById('trend-updated-time');
        if (!el) return;
        const now = new Date();
        el.textContent = `ê¸°ì¤€: í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ì¸ê¸° ì˜ìƒ(ì„ íƒí•œ ê¸°ê°„ ê¸°ì¤€)ì—ì„œ ìë™ ì¶”ì¶œ Â· ì—…ë°ì´íŠ¸ ${now.toLocaleTimeString()}`;
    }

    function updateTrendKeywords(keywordEntries) {
        currentTrendKeywords = keywordEntries || [];
        const listEl = document.getElementById('trend-keyword-list');
        if (!listEl) return;

        listEl.innerHTML = '';
        if (!currentTrendKeywords.length) {
            listEl.innerHTML = '<li><span class="trend-keyword">íŠ¸ë Œë“œ í‚¤ì›Œë“œë¥¼ ê³„ì‚°í•  ì˜ìƒ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</span></li>';
            return;
        }

        currentTrendKeywords.forEach((item, idx) => {
            const li = document.createElement('li');

            const spanKeyword = document.createElement('span');
            spanKeyword.className = 'trend-keyword';
            spanKeyword.textContent = `${idx + 1}. ${item.word}`;

            const spanScore = document.createElement('span');
            spanScore.className = 'trend-score-badge';
            spanScore.textContent = `score ${item.score.toFixed(1)}`;

            spanKeyword.addEventListener('click', () => {
                const searchInput = document.getElementById('searchInput');
                const searchBtn = document.getElementById('searchBtn');
                if (searchInput && searchBtn) {
                    searchInput.value = item.word;
                    searchBtn.click();
                }
            });

            li.appendChild(spanKeyword);
            li.appendChild(spanScore);
            listEl.appendChild(li);
        });

        updateTrendUpdatedTime();
    }

    function buildAndRenderTrendKeywords() {
        if (!currentBaseVideos || currentBaseVideos.length === 0) {
            updateTrendKeywords([]);
            return;
        }
        updateTrendKeywords(buildTrendKeywordsFromVideos(currentBaseVideos));
    }

    // ì¦ê²¨ì°¾ê¸°
    function loadFavorites() {
        try {
            const raw = window.localStorage.getItem('ytTrendFavorites');
            favoriteGroups = raw ? JSON.parse(raw) : {};
        } catch (e) {
            console.warn('ì¦ê²¨ì°¾ê¸° ë¡œë“œ ì‹¤íŒ¨:', e);
            favoriteGroups = {};
        }
        renderFavoriteButtons();
    }
    function saveFavorites() {
        try {
            window.localStorage.setItem('ytTrendFavorites', JSON.stringify(favoriteGroups));
        } catch (e) {
            console.warn('ì¦ê²¨ì°¾ê¸° ì €ì¥ ì‹¤íŒ¨:', e);
        }
    }
    function renderFavoriteButtons() {
        const wrapper = document.getElementById('favorite-buttons');
        if (!wrapper) return;

        wrapper.innerHTML = '';
        const names = Object.keys(favoriteGroups);

        if (!names.length) {
            wrapper.innerHTML = '<small class="text-muted">ë“±ë¡ëœ ì¦ê²¨ì°¾ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤.</small>';
            return;
        }

        names.forEach(name => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'd-inline-flex align-items-center me-2 mb-1';

            const btn = document.createElement('button');
            btn.className = 'btn btn-sm btn-outline-warning me-1 fav-group-btn';
            btn.textContent = `â­ ${name}`;
            btn.setAttribute('data-group', name);

            const delBtn = document.createElement('button');
            delBtn.className = 'btn btn-sm btn-outline-secondary fav-group-del';
            delBtn.textContent = 'ì‚­ì œ';
            delBtn.setAttribute('data-group', name);

            groupDiv.appendChild(btn);
            groupDiv.appendChild(delBtn);
            wrapper.appendChild(groupDiv);
        });

        wrapper.querySelectorAll('.fav-group-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const name = btn.getAttribute('data-group');
                const keywords = favoriteGroups[name] || [];
                if (!keywords.length) return;
                const combined = keywords.join(' ');
                const searchInput = document.getElementById('searchInput');
                if (searchInput) searchInput.value = combined;
                searchVideosByKeyword(combined);
            });
        });

        wrapper.querySelectorAll('.fav-group-del').forEach(btn => {
            btn.addEventListener('click', () => {
                const name = btn.getAttribute('data-group');
                if (favoriteGroups[name]) {
                    delete favoriteGroups[name];
                    saveFavorites();
                    renderFavoriteButtons();
                }
            });
        });
    }

    // ì¹´í…Œê³ ë¦¬ ë²„íŠ¼
    document.querySelectorAll('.category-button').forEach(button => {
        button.addEventListener('click', function() {
            document.querySelector('.category-button.active')?.classList.remove('active');
            this.classList.add('active');

            currentCategory = this.getAttribute('data-category');
            const categoryId = CATEGORIES[currentCategory];

            document.getElementById('category-title').textContent = this.textContent.trim();
            document.getElementById('searchInput').value = '';
            currentSearchKeyword = '';
            updateSocialLinks('');

            if (currentCategory === 'Live') fetchLiveVideos();
            else fetchPopularVideos(categoryId);
        });
    });

    // ì–¸ì–´ ìŠ¤ìœ„ì¹˜
    ['langKR', 'langEN', 'langJP'].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('change', (e) => {
            const target = e.target;
            if (!target.checked) { target.checked = true; return; }

            ['langKR', 'langEN', 'langJP'].forEach(otherId => {
                if (otherId !== id) {
                    const otherEl = document.getElementById(otherId);
                    if (otherEl) otherEl.checked = false;
                }
            });

            const categoryId = CATEGORIES[currentCategory];
            const keyword = document.getElementById('searchInput').value.trim();

            if (keyword) searchVideosByKeyword(keyword);
            else {
                if (currentCategory === 'Live') fetchLiveVideos();
                else fetchPopularVideos(categoryId);
            }
        });
    });

    // ê¸¸ì´ í•„í„°
    document.querySelectorAll('.duration-button').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelector('.duration-button.active')?.classList.remove('active');
            this.classList.add('active');
            currentDurationFilter = this.getAttribute('data-duration');
            updateVideoListAndStatus();
        });
    });

    // ì •ë ¬ í•„í„°
    document.querySelectorAll('.sort-button').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelector('.sort-button.active')?.classList.remove('active');
            this.classList.add('active');
            currentSortMode = this.getAttribute('data-sort');
            updateVideoListAndStatus();
        });
    });

    // ê¸°ê°„ í•„í„°
    document.querySelectorAll('.time-range-button').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelector('.time-range-button.active')?.classList.remove('active');
            this.classList.add('active');
            currentTimeRange = this.getAttribute('data-range');

            const categoryId = CATEGORIES[currentCategory];
            const keyword = document.getElementById('searchInput').value.trim();

            if (keyword) searchVideosByKeyword(keyword);
            else {
                if (currentCategory === 'Live') fetchLiveVideos();
                else fetchPopularVideos(categoryId);
            }
        });
    });

    // êµ¬ë…ì í•„í„°
    document.querySelectorAll('.subscriber-filter-checkbox').forEach(cb => {
        cb.addEventListener('change', function () {
            const range = this.getAttribute('data-range');

            if (range === 'all') {
                if (this.checked) {
                    currentSubscriberRanges = new Set(['all']);
                    document.querySelectorAll('.subscriber-filter-checkbox').forEach(other => {
                        if (other !== this) other.checked = false;
                    });
                } else {
                    this.checked = true;
                    currentSubscriberRanges = new Set(['all']);
                }
            } else {
                if (this.checked) {
                    currentSubscriberRanges.delete('all');
                    const allCb = document.getElementById('subFilterAll');
                    if (allCb) allCb.checked = false;
                    currentSubscriberRanges.add(range);
                } else {
                    currentSubscriberRanges.delete(range);
                    if (currentSubscriberRanges.size === 0) {
                        currentSubscriberRanges.add('all');
                        const allCb = document.getElementById('subFilterAll');
                        if (allCb) allCb.checked = true;
                    }
                }
            }

            updateVideoListAndStatus();
        });
    });

    // ê²€ìƒ‰ ë²„íŠ¼
    document.getElementById('searchBtn').addEventListener('click', () => {
        const keyword = document.getElementById('searchInput').value.trim();
        const categoryId = CATEGORIES[currentCategory];

        if (!keyword) {
            currentSearchKeyword = '';
            updateSocialLinks('');
            if (currentCategory === 'Live') fetchLiveVideos();
            else fetchPopularVideos(categoryId);
        } else {
            searchVideosByKeyword(keyword);
        }
    });
    document.getElementById('searchInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') document.getElementById('searchBtn').click();
    });

    document.addEventListener('DOMContentLoaded', () => {
        // âœ… ë¨¼ì € ì €ì¥ëœ API í‚¤ ë¡œë“œ
        loadApiKey();

        // ì¦ê²¨ì°¾ê¸° ë¡œë“œ
        loadFavorites();

        // API í‚¤ ë²„íŠ¼ ì—°ê²°
        document.getElementById('saveApiKeyBtn').addEventListener('click', saveApiKey);
        document.getElementById('clearApiKeyBtn').addEventListener('click', clearApiKey);

        updateTrendRegionInfo();

        // ì´ˆê¸° ë¡œë”©
        fetchPopularVideos(CATEGORIES[currentCategory]);

        // ì¦ê²¨ì°¾ê¸° ì¶”ê°€/ì—…ë°ì´íŠ¸
        const addFavBtn = document.getElementById('addFavBtn');
        if (addFavBtn) {
            addFavBtn.addEventListener('click', () => {
                const nameInput = document.getElementById('favGroupName');
                const kwInput = document.getElementById('favKeywords');
                if (!nameInput || !kwInput) return;

                const name = nameInput.value.trim();
                const kwStr = kwInput.value.trim();

                if (!name || !kwStr) {
                    alert('ëŒ€íƒœê·¸ ì´ë¦„ê³¼ ì†Œíƒœê·¸ í‚¤ì›Œë“œë¥¼ ëª¨ë‘ ì…ë ¥í•´ ì£¼ì„¸ìš”.');
                    return;
                }

                const keywords = kwStr.split(/[,\s]+/).map(k => k.trim()).filter(k => k.length > 0);
                if (!keywords.length) {
                    alert('ì†Œíƒœê·¸ í‚¤ì›Œë“œë¥¼ í•˜ë‚˜ ì´ìƒ ì…ë ¥í•´ ì£¼ì„¸ìš”.');
                    return;
                }

                favoriteGroups[name] = keywords;
                saveFavorites();
                renderFavoriteButtons();
                alert(`"${name}" ì¦ê²¨ì°¾ê¸°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
            });
        }

        // 30ë¶„ë§ˆë‹¤ ìë™ ìƒˆë¡œê³ ì¹¨
        setInterval(() => {
            const categoryId = CATEGORIES[currentCategory];
            if (currentCategory === 'Live') {
                fetchLiveVideos();
            } else if (currentSearchKeyword) {
                searchVideosByKeyword(currentSearchKeyword);
            } else {
                fetchPopularVideos(categoryId);
            }
        }, 30 * 60 * 1000);
    });
</script>
</body>
</html>
